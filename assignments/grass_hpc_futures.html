<h2>Urban growth modeling with FUTURES on Henry2</h2>
Here we demonstrate how to run parallel jobs in GRASS using an urban growth modeling case study.

<p>
We will all share PERMANENT mapset of Location <code>albers</code> with prepared data and each student will create
their own mapset (using their user name) for computations in their own folder (<a href="https://github.com/ncsu-geoforall-lab/grass-gis-on-hpc-henry2/blob/main/docs/data.md#sharing-a-database-between-different-users">
    description of this setup</a>).
Typically, the PERMANENT Mapset may be in a research storage and you may not have write access to it.
Please do not modify anything in the PERMANENT mapset.

<pre><code>
mkdir /share/gis714s22/$USER/grassdata/albers
ln -s /share/gis714s22/grassdata/albers/PERMANENT/ /share/gis714s22/$USER/grassdata/albers/
</code></pre>


Install <a href="https://github.com/ncsu-landscape-dynamics/pynodelauncher">pynodelauncher</a>:

<pre><code>
module use --append /usr/local/usrapps/geospatial/modulefiles
module load grass/8.1
module load PrgEnv-intel
module load gcc
pip install git+https://github.com/ncsu-landscape-dynamics/pynodelauncher.git
</code></pre>

Start GRASS GIS in a temporary mapset mapset:
<pre><code>
grass --tmp-mapset /share/gis714s22/$USER/grassdata/albers/
</code></pre>

Check you can access the data:
<pre><code>
g.list type=raster,vector  -mt
</code></pre>

Install FUTURES extension:
<pre><code>
g.extension r.futures
</code></pre>

Exit GRASS session (temporary mapset will be removed):
<pre><code>
exit
</code></pre>

We won't be going through the entire workflow, but rather demonstrating some parallel computation techniques on selected
parts of the workflow. The next three sections (computing slope, distance to features, and development pressure)
are independent, so you can submit all the jobs at the same time.


<h3>Computing slope</h3>
Tool <code>r.slope.aspect</code> can take advantage of multiple cores, because it uses OpenMP library to automatically distribute
work among certain number of threads. OpenMP uses shared memory and therefore the job needs to run on a single node.
We will submit a parallel job,
that requests 4 cores and specifies that those cores need to be on one computing node (<code>span[hosts=1]</code>).
The number of cores specified in the header should match the number in <code>nprocs</code> parameter.
We will compute slope in a separate mapset called slope.
Note that we don't have to set computational region for the new mapset because all new mapsets are using default region
that is set in PERMANENT.

<pre><code>
#!/bin/tcsh
#BSUB -n 4
#BSUB -W 15
#BSUB -R "rusage[mem=1GB]"
#BSUB -R span[hosts=1] 
#BSUB -oo slope_out
#BSUB -eo slope_err
#BSUB -J slope

module use --append /usr/local/usrapps/geospatial/modulefiles
module load grass/8.1

# remove this mapset which may exist from a previous run of this job
rm -rf /share/gis714s22/$USER/grassdata/albers/slope

# create a new mapset with -c flag
grass -c /share/gis714s22/$USER/grassdata/albers/slope --exec r.slope.aspect elevation=DEM slope=slope nprocs=4
</code></pre>

<span class="question">
    Submit this job with a different number of cores and compare the run time. Change the name of the mapset if you want to run it at the same time.
</span>

<h3>Computing distance</h3>
Here we compute distance to roads, water and forest that will serve as predictors.
Since tool <code>r.grow.distance</code> is not internally parallelized, we will execute distance to roads, water, and forest
so that they run concurrently using 3 cores. This can be simply achieved by executing them in the background.

<pre><code>
#!/bin/tcsh
#BSUB -n 3
#BSUB -W 3:00
#BSUB -R "rusage[mem=1GB]"
#BSUB -oo dist_out
#BSUB -eo dist_err
#BSUB -J dist

module use --append /usr/local/usrapps/geospatial/modulefiles
module load grass/8.1

rm -rf /share/gis714s22/$USER/grassdata/albers/roads
rm -rf /share/gis714s22/$USER/grassdata/albers/water
rm -rf /share/gis714s22/$USER/grassdata/albers/forest

# run in background by appending & after the tool
grass -c /share/gis714s22/$USER/grassdata/albers/roads --exec r.grow.distance input=roads distance=dist_to_roads -m &
grass -c /share/gis714s22/$USER/grassdata/albers/water --exec r.grow.distance input=water distance=dist_to_water -m &
grass -c /share/gis714s22/$USER/grassdata/albers/forest --exec r.grow.distance input=forest distance=dist_to_forest -m &
# this will wait for the processes to finish before starting the next set of processes
wait
grass /share/gis714s22/$USER/grassdata/albers/roads --exec r.mapcalc "log_dist_to_roads = log(dist_to_roads + 1)" &
grass /share/gis714s22/$USER/grassdata/albers/water --exec r.mapcalc "log_dist_to_water = log(dist_to_water + 1)" &
grass /share/gis714s22/$USER/grassdata/albers/forest --exec r.mapcalc "log_dist_to_forest = log(dist_to_forest + 1)" &
wait
</code></pre>

<h3>Computing development pressure</h3>
Here we combine the two previous approaches to compute development pressure for 2001 and 2019.
Tool <a href="https://grass.osgeo.org/grass80/manuals/addons/r.futures.devpressure.html">r.futures.devpressure</a>
is internally parallelized, so we can run the tool for both years concurrently and for each of them request certain number of cores.
Notice that we need to request twice as many cores then (on a single node).

<pre><code>
#!/bin/tcsh
#BSUB -n 16
#BSUB -W 10:00
#BSUB -R span[hosts=1]
#BSUB -R "rusage[mem=2GB]"
#BSUB -oo devpressure_out
#BSUB -eo devpressure_err
#BSUB -J devpressure

module use --append /usr/local/usrapps/geospatial/modulefiles
module load grass/8.1

rm -rf /share/gis714s22/$USER/grassdata/albers/devpressure_2001
rm -rf /share/gis714s22/$USER/grassdata/albers/devpressure_2019

# run in background by appending & after the tool
grass -c /share/gis714s22/$USER/grassdata/albers/devpressure_2001 --exec r.futures.devpressure input=urban_no_roads_2001 output=devpressure_2001 size=20 gamma=1 nprocs=8 &
grass -c /share/gis714s22/$USER/grassdata/albers/devpressure_2019 --exec r.futures.devpressure input=urban_no_roads_2019 output=devpressure_2019 size=20 gamma=1 nprocs=8 &

# this will wait for the processes to finish
wait
</code></pre>

<h3>Running the simulation</h3>

Once all the previous steps are finished, we can run the futures simulation.
We will use already precomputed input CSV files.
First, in your home create a new file named "pga.sh" with the following content:

<pre><code>
#!/bin/bash

g.region raster=state_${1}
r.mask raster=masking
r.futures.pga developed=urban_2019 development_pressure=devpressure_2019@devpressure_2019 \
    compactness_mean=0.5 compactness_range=0.1 discount_factor=1 \
    predictors=log_dist_to_forest@forest,log_dist_to_roads@roads,log_dist_to_water@water,slope@slope \
    n_dev_neighbourhood=20 devpot_params=/share/gis714s22/input_csv/best_model.csv num_neighbors=4 seed_search=probability \
    development_pressure_approach=gravity gamma=1 scaling_factor=1 num_steps=31 \
    subregions=state_${1} demand=/share/gis714s22/input_csv/demand_${1}.csv \
    output=out_state_${1}_seed_${2} patch_sizes=/share/gis714s22/input_csv/patch_sizes_${1}.csv memory=12 random_seed=${2}
</code></pre>

Then create a script "bsub_futures.sh" with the content below:

<pre><code>
#!/bin/tcsh
#BSUB -n 19
#BSUB -R "rusage[mem=120GB]"
#BSUB -R span[ptile=9]
#BSUB -W 40:00
#BSUB -oo futures_out
#BSUB -eo futures_err
#BSUB -J futures

module use --append /usr/local/usrapps/geospatial/modulefiles
module load grass/8.1
module load PrgEnv-intel


rm -f /share/gis714s22/${USER}/pga_jobs.sh
foreach SEED (`seq 1 10`)
    foreach STATE  ( 1 12 13 37 45 47 )
        rm -rf /share/gis714s22/$USER/grassdata/albers/pga_${STATE}_${SEED}
        echo grass -c /share/gis714s22/$USER/grassdata/albers/pga_${STATE}_${SEED} --exec bash /home/${USER}/pga.sh ${STATE} ${SEED} >> /share/gis714s22/${USER}/pga_jobs.sh
    end
end

mpiexec python -m mpi4py -m pynodelauncher /share/gis714s22/${USER}/pga_jobs.sh
</code></pre>

This submission script first generates a file, which looks like this:

<pre>
grass -c /share/gis714s22/akratoc/grassdata/albers/pga_1_1 --exec bash /home/akratoc/pga.sh 1 1
grass -c /share/gis714s22/akratoc/grassdata/albers/pga_12_1 --exec bash /home/akratoc/pga.sh 12 1
...
</pre>
This file contains commands that will be distributed for computation across multiple nodes, each one of them computing the simulation
for single state an random seed.
Notice the submission parameters, there are slightly more complex. In the script "pga.sh" we limited each r.futures.pga run to 12 GB of memory max, so on a node with 128 GB of memory we can fit only around
9 concurrent simulations (we need to keep some padding). Therefore, we specify that with <code>rusage[mem=120GB]</code> and <code>span[ptile=9]</code>. When we request 19 cores, that will result in requesting 2 x 128GB nodes.
We request 19 instead of 18 to include one extra core for MPI thread management. There will be total of 60 (6 states x 10 seeds) FUTURES computations on 18 cores, once a computation from the list is finished
the next one is started. When you submit your job, it may be pending for a while, you are requesting a lot of resources for a long time.


<h3>Postprocessing</h3>
We need to patch the results for individual states. For that we will use
tool <code>r.patch</code> which is internally parallelized. Since we
need to do that for each random seed, we can use MPI to distribute the computation across
multiple nodes. This example shows how to submit a
<a href="https://projects.ncsu.edu/hpc/Documents/hybridjobs.php">"hybrid job"</a> that
distributes each r.patch call on a different node,
allowing r.patch to use all the cores available on that node (<code>nprocs --all</code>).
<p>
Note: this is not the most efficient way of using HPC resources.
One problem is that r.patch will not run much faster with 12 cores than 4. Also, pynodelauncher
will use one core for managing threads, which (because of using <code>-x</code>) results in one almost idle node.
More complex options to improve this would be to
e.g., place multiple r.patch calls on one node and/or request specific node size (e.g., <code>-R "select[qc]"</code> for 8 available cores).


<pre><code>
#!/bin/tcsh
#BSUB -n 6
#BSUB -x
#BSUB -R span[ptile=1]
#BSUB -W 1:00
#BSUB -oo patch_out
#BSUB -eo patch_err
#BSUB -J patch

module use --append /usr/local/usrapps/geospatial/modulefiles
module load grass/8.1
module load PrgEnv-intel


rm -f /share/gis714s22/${USER}/patch_jobs.sh
foreach SEED (`seq 1 10`)
    # list results for each state for a single seed and save to a variable
    set MAPS=$(grass --tmp-mapset /share/gis714s22/$USER/grassdata/albers --exec \
         g.list type=raster pattern="out_state_*_seed_${SEED}" mapset="*" -m separator=comma)
    rm -rf /share/gis714s22/$USER/grassdata/albers/results_${SEED}
    echo grass -c /share/gis714s22/$USER/grassdata/albers/results_${SEED} --exec  r.patch input=${MAPS} output="out_seed_${SEED}" nprocs=$(nproc --all) >> /share/gis714s22/${USER}/patch_jobs.sh
end

mpiexec python -m mpi4py -m pynodelauncher /share/gis714s22/${USER}/patch_jobs.sh
</code></pre>

<span class="question">
    Report the run times for all your computations and include a figure with the results.
</span>
